## 关于代码分层的理解

> 首页，**分层的目的：高内聚，低耦合**。虽然有时候一个controller方法里面仅仅调用一个service的方法，
一个service方法里面仅仅调用一个到dao层里的方法，但是这几层还是非常有必要存在的。
> * 一、 这样看起来结构清晰，
> * 二、可扩展性和适应性更加强，比如将来用户的业务逻辑发生变化，你需要做的仅仅就是在service层中
多调用一个方法即可，而不是需要对代码有太多的改动。
> * 三、维护更加简单，将来维护这个代码的不一定是你本人或者开发这个系统的人，所以，如果你严格按照这种架构来写的话，
他们只需要有这种分层意识，很容易掌握这个系统，也很容易能够对问题进行排查和修改。

### DAO (Mapper)

dao层只是负责和数据库交互


### service

service层写业务逻辑代码，并且注意需要将每一个独立的功能写成一个单独的方法，方便其他的代码进行调用。

### controller (Endpoint)

controller层只是负责从service获取数据，返回给view层。

**注意**：
1. 建议所有的接口返回统一的格式R，方便调用者封装；
2. R只允许在controller层使用，不允许往后传（service，dao），类似与Map，json也允许，因为可读性大大降低；
3. **controller只做参数格式转换，如果没有参数需要转换的，那么就一行代码。日志/参数校验/权限判断建议放在service里面，
毕竟controller基本无法重用，而service重用比较多。**

### facade

> 在service类之间耦合的情况下引入外观模式

facade 层负责降低service类之间耦合，此时controller层只是负责从facade层获取数据，返回给view


### Entity DTO VO 的应用

> * 展示层返回客户端使用VO，展示层把VO转换成服务成对应所要求的DTO,传输给服务层；
> * 展示层（controller）和服务层（service）之间进行数据交互使用DTO，服务层根据DTO的数据构造一个DO（entity），调用ORM工具，完成持久化操作；
> * 服务间调用使用DTO；
> * Entity为ORM框架中的实体，对应到数据库表；

在以下才场景中，我们可以考虑把VO与DTO二合为一

- 当需求非常清晰稳定，而且客户端很明确只有一个的时候，没有必要把VO和DTO区分开来;
